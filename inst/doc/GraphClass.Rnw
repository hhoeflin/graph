%
% NOTE -- ONLY EDIT GraphClass.Rnw!!!
% GraphClass.tex file will get overwritten.
%
%\VignetteIndexEntry{Graph Design}
%\VignetteDepends{graph}
%\VignetteKeywords{Graph}
%\VignettePackage{graph}
\documentclass{article}

\usepackage{hyperref}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}

\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}


\newcommand{\classdef}[1]{%
  {\em #1}
}

\begin{document}

\section{Discussion}

The purpose of this document is to describe an implementation of a
class structure for graphs (we define classes for both nodes and
edges) and consider some different problems that can arise.

There are many different ways to represent a graph and to deal with
the edges and nodes within that graph.
We would like to determine the operations that need to be performed on
a graph. These would essentially define the interface -- those
components that any one would need to implement to have access to
certain algorithms.

The \Rpackage{graph} currently supports a number of different basic
graph classes designed to support different representations of a
graph. But some of the design decisions there are in need of review.

At its most basic level a graph is a pair of sets, $G=(V,E)$ where $V$
is the set of nodes and $E$ is the set of edges, which are determined
by relationships that exist between the nodes.  If we let $n = |V|$,
be the number of nodes then, excluding self-loops there are at most
$n$ choose 2 edges in $G$.

Our initial implementation made the \textit{edgemode} a property of
the graph, but now that we are considering multigraphs, it seems that
this might be better done as a property of the edges.

\subsection{The graph class}

The \Rclass{graph} class is designed to hold simple graphs. There can
be at most one edge (relationship) between any two nodes, but this
edge can have multiple attributes.  The \Rclass{graph} class also
supports self-loops.  Nodes can have arbitrary attributes associated
with them.  For both nodes and edges if one edge or node has a
particular type of attribute then all nodes and edges must have that
attribute. 

\textit{This raises the question of whether we should use the
  \Rclass{AnnotatedDataFrame} class from Biobase here as a way to
    implement general node and edge attributes.}

There are currently implementations for the \Rclass{graphNEL} class,
where nodes are a vector and edges are a list, each element of the
list correspondes to one node and the values are nodes corresponding
to the out-edges from that node.  If the graph is directed then all
edges essentially appear twice.

The \Rclass{graphAM} class, which stores the edge information in an
adjacency matrix.  The matrix must be square and the row names must
match the column names.  If the graph is undirected then the matrix
must also be symmetric.

There are two specialized classes, \Rclass{distGraph} which takes a
distance matrix directly and has special thresholding capabilities. It
is not clear whether this should be a specialization of the
\Rclass{graphAM} class or not.

The second specialized class is a \Rclass{clusterGraph} which can be
used to represent the output of a clustering algorithm as a graph.
Samples represent nodes and all samples in the same cluster have
edges, while samples in distinct clusters do not.  Instances of this
class must have their edgemode as \texttt{undirected}, if the edgemode
is reset then coercion to some other mode of graph is needed.


\subsection{Some Details}

Once both nodes and edges are instances of classes they will be quite
large. In order to reduce the storage requirements (especially for
large graphs) using integer indices may be beneficial.

The minimum amount of storage required is $|V|+|E|$. If we use an 
incidence matrix representation then the storage is $|V|^2$.
If we use a node and edge list representation then the storage
requirements are $|V|+2|E|$. When either $|V|$ or $|E|$ are large
these mechanisms will not be especially efficient.
In some cases it may be better to keep the actual node and edge data
stored in hash tables and keep other integer vectors available for
accessing the necessary components.

\subsubsection{Representation of Edges}
\label{sec:edgerep}

We have taken the approach of allowing the representation of the edge
sets to not contain every node.  When the graphs are sparse this can
be a fairly large savings in space, but it means that one cannot
determine the nodes in a graph from the edges in the graph.

Also, for the \Rclass{graphNEL} class we do not store the names of the
nodes in the NEL, but rather indexes into a the node vector.  This is
important for allowing us to perform permutations on the nodes of a
graph, but causes a number of problems when subsetting graphs, and
means that knowledge of the edges does not provide knowledge of the
nodes. 

\section{Multi-graphs}

There are no clear and widely used definitions for multi-graphs, so
here we will make clear a definition that we believe will be useful
for biological computations.  We define a multi-graph to consist of
two components, one a set of nodes and the second a list of edge
sets. Each edge set corresponds to a potentially different set of
relationships between the nodes (which are common to all edge
sets). We denote this by $G=(V, E_L)$, where $V$ is the set of nodes
and $E_L = (E_1, \ldots, E_L)$ is a collection of $L$ edge sets. Each
with a potentially distinct set of relationships. The edge sets are
essentially identical to the edge sets for a graph, and hence can have
arbitrary attributes associated with them, the edges can be either
\textit{directed} or \textit{undirected} and self-loops are allowed.

It is not clear whether there should be distinct types of
multigraphs as there are graphs.  It will surely be more flexible to
support a list of edge sets, and to allow these to have different
structures. 

Current definition extends the \Rclass{graph} class (mainly to reuse
code that deals with arbitrary node and edge attributes - but note
that this may be problematic for nodes) and introduces the following
slots:
\begin{description}
\item[nodes] A vector of node identifiers.
\item[edgeL] A possibly named list of instances of the \Rclass{edgeSet} class.
\end{description}

The \Rclass{edgeSet} class is a virtual class with several different
extensions of it. These include a \Rclass{edgeSetNEL} and an
\Rclass{edgeSetAM}, others will be added once the interface
stabilizes. 

\subsection{Methods}

In some ways it would be most natural to have \Robject{edges} methods
for the \Rclass{edgeSet} class the issues raised in
Section~\ref{sec:edgerep} seem to preclude this and it only seems to
make sense to have \Robject{node} and \Robject{edges} methods for the
\Rclass{multiGraph} class.

\subsection{Use Cases}

An important motivator for the \Rclass{multiGraph} class is the
representation of data from protein interaction experiments.  Our goal
is to represent these data in terms of what interactions were tested,
and of those which ones are either positive or negative.

\section{Bipartite Graphs}

A bipartite graph graph is a graph where the nodes can be divided into
two sets, say $V_1$ and $V_2$,  such that all edges are between
members of $V_1$ and members of $V_2$ and there are no edges between
any two elements of $V_1$, nor of $V_2$.


\end{document}



