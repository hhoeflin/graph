%
% NOTE -- ONLY EDIT howtogenefilter.Rnw!!!
% Biobase.tex file will get overwritten.
%
%\VignetteIndexEntry{Graph}
%\VignetteDepends{graph, cluster}
%\VignetteKeywords{Graph}
%\VignettePackage{graph}
\documentclass{article}

\usepackage{hyperref}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\newcommand{\classdef}[1]{%
  {\em #1}
}

\begin{document}
\title{RFC: Attributes for graph objects}
\author{Seth Falcon}
\maketitle


\section{Introduction}

<<setup, hide=TRUE,echo=FALSE>>=
simpleInciMat <- function() {
    ## Here's a simple graph for testing
    ##    a           b
    ##    |\         /|
    ##    | \___c___/ |
    ##    |     |     |
    ##    \     |     /
    ##     \____d____/
    ##
    ##
    mat <- matrix(c(0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0),
                  byrow=TRUE, ncol=4)
    rownames(mat) <- letters[1:4]
    colnames(mat) <- letters[1:4]
    mat
}


simpleDirectedGraph <- function() {
    ## Here's a simple graph for testing
    ##    a           b
    ##    |\         /^
    ##    | \__>c<__/ |
    ##    |     ^     |
    ##    \     |     /
    ##     \___>d____/
    ##
    ##
    mat <- matrix(c(0, 0, 1, 1,
                    0, 0, 1, 0,
                    0, 0, 0, 0,
                    0, 1, 1, 0),
                  byrow=TRUE, ncol=4)
    rownames(mat) <- letters[1:4]
    colnames(mat) <- letters[1:4]
    mat
    new("graphIM", inciMat=mat, edgemode="directed")
}

@ 

The \Rpackage{graph} package provides representations of graphs (nodes
and edges) as S4 classes.  The current implementation lacks a generic
and easy to use mechanism for adding attributes to the nodes and edges
of a graph.  This RFC proposes modification of existing graph classes
to allow such attributes.

\section{Motivation}

Many graph algorithms have a need for accessing node and edge
attributes as part of the computation.  The most obvious example is a
``weight'' attribute on the edges.  Storing the attributes as part of
the graph object allows graph algorithms to easily use these attributes.

Adding attributes to graph elements is a common feature of other
systems providing tools for working with graphs.  The LEDA\footnote{A
platform for combinatorial and geometric computing by K. Mehlhorn and
S. Naher} system, for example, provides a variety of storage
mechanisms for node and edge attributes via C++ templates that allow
associating data of arbitrary types with the nodes and edges of a graph.

Graph attributes are also used heavily for graph presentation to
specify the visual style of graph elements.  The graphviz
package\footnote{Gansner and North, 1999}
specifies a fixed set of attributes that can be assigned to edges,
nodes, the root graph, subgraphs and cluster subgraphs.  For details
on the attributes defined by graphviz, see
\Rcode{http://www.graphviz.org/pub/scm/graphviz2/doc/info/attrs.html}.

The \Rpackage{Rgraphviz} package allows the user to specify attributes
that get passed to graphviz to modify the display of the graph.  These
attributes are specified as lists of lists that get passed into the
plotting functions.  The attributes are not stored with the graph data
structures.

An easy to use mechanism to store arbitrary attributes for the nodes
and edges of a graph will be helpful in implementing graph algorithms.
The attributes that are stored with the graph object could also be
used to programatically generate presentation attributes suitable for
Rgraphviz via user-specified functions.


\section{Edge Attributes}

All edges in a graph should support the same set of attributes.  The
user can define and access this set of supported attributes via the
\Rmethod{edgeSet*} methods.  All edge attributes have a default
value.  If the value of an attribute has not been specified for a
particular edge in a graph, the default value as defined in the
\Rcode{edgeSet} will be used.

By default, a \Rclass{graph} instance will not have any defined edge
attributes.  The user can add edge attributes to a graph by specifying
the attribute name and default value using either the
\Rmethod{edgeSetAttributes} method to assign all attributes at once or
the \Rmethod{edgeSetAttr} method to assign a single attribute.  Once a
list of attributes have been defined for the \Rcode{edgeSet}, the
attributes of individual edges can be customized using the
\Rmethod{edgeAttributes} method.

The following paragraphs demonstrate the proposed interface.

Create a graph and specify edge attributes ``weight'' and ``type''
with default values of 1 and ``I'', respectively.  Edge attributes are
defined using a named list.

<<edgeSet1>>=
library("graph")
mat <- simpleInciMat()
g1 <- new("graphIM", inciMat=mat)
myEdgeAttributes <- list(weight=1, type="I")
edgeSetAttributes(g1) <- myEdgeAttributes
edgeSetAttributes(g1)
@ 

You can also access a particular attribute using \Rmethod{edgeSetAttr}
and default values can be reassigned using this same method:

<<edgeSet2>>=
edgeSetAttr(g1, "weight")
edgeSetAttr(g1, "weight") <- 200
edgeSetAttr(g1, "weight")
@ 

You can add new attributes along with a default value:
<<edgeSet4>>=
edgeSetAttr(g1, "prob") <- 0.5
edgeSetAttributes(g1)
@ 

The attributes of a particular edge in the graph is accessed using the
\Rmethod{edgeAttributes} method.  Only attribute names defined via an
\Rmethod{edgeSet*} method can be defined for a particular edge.  If
the user does not customize the attribute for a particular edge, then
its attributes are the defaults for the \Rcode{edgeSet}.

<<edgeSet5>>=
edgeAttributes(g1, "a", "d")
edgeAttributes(g1, "a", "d") <- list(weight=800, type="II", prob=0.2)
edgeAttributes(g1, "a", "d")

edgeAttributes(g1, "a", "c") <- list(weight=11)
edgeAttributes(g1, "a", "c")
@ 

Note that the return value of \Rmethod{edgeAttributes} is a list so
that we can support vectorized access such as the following:

<<edgeSet7>>=
edgeAttributes(g1, from="a")
@ 


\section{Node Attributes}

The interface to node attributes is similar.  Here are the proposed methods:

<<nodeSet1,eval=FALSE>>=
nodeSetAttributes(g1) 
nodeSetAttr(g1)
nodeAttributes(g1, nodes)
@ 

\section{Implementation Notes}

The edge attributes as described above have been implemented for the
\Rclass{graphIM} class in the devel version of the \Rpackage{graph}
package.  The node attributes have noy yet been implemented.  Please
see the Subversion source repository for implementation details.

\section{Alternate Interface}

Based on comments from Li Long...

<<defaultAttributes>>=
## Getting default attributes
nodeDataDefaults(g1)
nodeDataDefaults(g1, attr="weight")

edgeDataDefaults(g1)
edgeDataDefaults(g1, attr="weight")

## Setting/creating default attributes
nodeDataDefaults(g1) <- list(weight=1, prob=.5)
nodeDataDefaults(g1, attr="weight") <- 1

edgeDataDefaults(g1) <- list(weight=1, prob=.5)
edgeDataDefaults(g1, attr="weight") <- 1
@ 

<<customizingAttributes, eval=FALSE>>=
## Getting attributes

nodeData(g1, x=c("n1", "n2"), attr="weight")
nodeData(g1, attr="weight") ## all nodes

## allow k/k, 1/k, k/1 for from/to lengths
edgeData(g1, from=c("n1", "n2"), to=c("n3", "n4"), attr="weight")
edgeData(g1, from="n1", to=c("n3", "n4"), attr="weight")
edgeData(g1, from=c("n1", "n2"), to="n3", attr="weight")
edgeData(g1, from=c("n1", "n2"), attr="weight")
edgeData(g1, to=c("n1", "n2"), attr="weight")
edgeData(g1, attr="weight")  ## all edges


## Setting attributes
## set same attr list for multiple nodes
nodeData(g1, x=c("n1", "n2"), attr="weight") <- 50
nodeData(g1, x=c("n1", "n2"), attr="weight") <- c(50, 40)
nodeData(g1, attr="weight") <- 50
## if you want to assign the value c(50, 40) to each of n1 and n2 do this
nodeData(g1, x=c("n1", "n2"), attr="weight") <- I(c(50, 40))


## set same attr list for multiple edges
edgeData(g1, from=c("n1", "n2"), to=c("n3", "n4"), attr="weight") <- 50
edgeData(g1, from=c("n1", "n2"), to=c("n3", "n4"), attr="weight") <- c(50, 40)
edgeData(g1, from=c("n1", "n2"), attr="weight") <- 50
edgeData(g1, to=c("n1", "n2"), attr="weight") <- 50

## possibly consider
nodeData(g1) <- someDataFrame
edgeData(g1) <- someDataFrame
@ 

\end{document}

